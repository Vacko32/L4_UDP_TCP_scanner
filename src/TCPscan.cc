#include "TCPscan.hh"

extern int GLOBAL_TIMEOUT;

tcp_socket::tcp_socket(char* domain, int port, std::vector<std::string> interfaces_addresses,
                       std::string mainInterface) {
  int status;  // default 0
  memset(&hints, 0, sizeof hints);
  hints.ai_family = AF_UNSPEC;  // v4 and v6
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags = 0;
  char ipstr[INET6_ADDRSTRLEN];

  status = getaddrinfo(domain, NULL, &hints, &res);

  if (status != 0) {
    std::cerr << "getaddrinfo: " << gai_strerror(status) << std::endl;
    throw std::runtime_error("Error(3): getaddrinfo failed");
  }

  struct addrinfo* r;
  for (r = res; r != NULL; r = r->ai_next) {
    void* addr;
    const char* ipver;
    if (r->ai_family == AF_INET) {
      struct sockaddr_in* ipv4 = (struct sockaddr_in*)r->ai_addr;
      addr = &(ipv4->sin_addr);
      ipver = "IPv4";
    } else {
      struct sockaddr_in6* ipv6 = (struct sockaddr_in6*)r->ai_addr;
      addr = &(ipv6->sin6_addr);
      ipver = "IPv6";
    }

    inet_ntop(r->ai_family, addr, ipstr, sizeof ipstr);
    adresses.push_back(ipstr);
  }

  // for each address and for each adress of interfaces make packet and send it
  // if atleast on one address we get open, the port is considered as being closed.
  int temp_res = 1;
  for (std::string i : adresses) {
    for (std::string j : interfaces_addresses) {
      setsocket(i, IPPROTO_TCP, j);
      temp_res = craft_packet(j, i, port);
      if (temp_res == 0) {
        return;
      }
      setsocket(i, IPPROTO_TCP, j);
      temp_res = craft_packet(j, i, port);
      if (temp_res == 0) {
        return;
      }
    }
    std::cout << i << " " << port << " tcp filtered" << std::endl;
  };
};

void tcp_socket::setsocket(std::string ip_adress, int st, std::string bind_adr) {
  st = IPPROTO_TCP;
  int version;
  for (char i : ip_adress) {
    if (i == '.') {
      version = PF_INET;
      break;
    } else if (i == ':') {
      version = PF_INET6;
      break;
    }
  }

  sockfd = socket(version, SOCK_RAW, st);
  if (sockfd == -1) {
    throw std::runtime_error("Error(4): udp_socket creation failed");
  }
};

/**
 * @brief Calculates the one's complement checksum for a given data block.
 *
 * This function calculates the checksum of a given buffer using the
 * one's complement method. It is commonly used in networking protocols
 * such as TCP/IP to ensure data integrity.
 *
 * The checksum calculation works by summing 16-bit words and handling
 * any overflow with carry bits. If the length of the buffer is odd, the
 * last byte is added separately. The result is then negated (one's complement).
 *
 * @param b Pointer to the data buffer to calculate the checksum for.
 * @param len Length of the data buffer in bytes.
 *
 * @return The computed checksum as a 16-bit unsigned short.
 *
 * @note This function was generated by ChatGPT.
 */
unsigned short checksum(void* b, int len) {
  unsigned short* buf = (unsigned short*)b;
  unsigned int sum = 0;
  unsigned short result;

  // Calculate sum of all 16-bit words
  for (sum = 0; len > 1; len -= 2) {
    sum += *buf++;
  }

  // If there is a left over byte, add it
  if (len == 1) {
    sum += *(unsigned char*)buf;
  }

  // Add carry to the sum (one's complement addition)
  sum = (sum >> 16) + (sum & 0xFFFF);
  sum += (sum >> 16);
  result = ~sum;  // One's complement of sum
  return result;
}

/**
 * @brief Craft a packet
 *
 * @param source,       source adress
 * @param destination,  destination adress
 * @param port,         port that needs to be scanned
 * @return int,         0 on succes else, 1
 *
 */
int tcp_socket::craft_packet(std::string source, std::string destination, int port) {
  int type1 = 0, type2 = 0;
  for (char i : source) {
    if (i == '.') {
      type1 = PF_INET;
      break;
    } else if (i == ':') {
      type1 = PF_INET6;
      break;
    }
  }
  for (char i : destination) {
    if (i == '.') {
      type2 = PF_INET;
      break;
    } else if (i == ':') {
      type2 = PF_INET6;
      break;
    }
  }
  if (type1 != type2) {
    return 1;  // unseccessfull
  } else if (type1 == PF_INET) {
    // both are IPv4
    memset(&ip_header, 0, sizeof(ip_header));
    ip_header.version = 4;
    ip_header.ihl = 5;
    ip_header.tos = 0;
    ip_header.tot_len = sizeof(ip_header) + sizeof(tcp_header);
    ip_header.id = htons(22232);
    ip_header.frag_off = 0;
    ip_header.ttl = 64;  // time to live
    ip_header.protocol = IPPROTO_TCP;
    ip_header.check = 0;  // for now
    ip_header.saddr = inet_addr(source.c_str());
    ip_header.daddr = inet_addr(destination.c_str());

    // now the tcp header
    tcp_header.source = htons(22232);
    tcp_header.dest = htons(port);
    tcp_header.seq = 0;
    tcp_header.ack_seq = 0;
    tcp_header.doff = 5;  // tcp header size
    tcp_header.fin = 0;
    tcp_header.syn = 1;
    tcp_header.rst = 0;
    tcp_header.psh = 0;
    tcp_header.ack = 0;
    tcp_header.urg = 0;
    tcp_header.window = htons(5840);  // maximum allowed window size
    tcp_header.check = 0;             // for now
    tcp_header.urg_ptr = 0;

    // now we are left with calculating checkcum
    // we will be using pseudo header for that
    psh.source_address = inet_addr(source.c_str());
    psh.dest_address = inet_addr(destination.c_str());
    psh.placeholder = 0;
    psh.protocol = IPPROTO_TCP;
    psh.tcp_length = htons(sizeof(tcp_header));

    int packet_size = sizeof(struct pseudo_header) + sizeof(struct tcphdr);
    char* pseudopacket = new char[packet_size];
    memcpy(pseudopacket, &psh, sizeof(struct pseudo_header));
    memcpy(pseudopacket + sizeof(struct pseudo_header), &tcp_header, sizeof(struct tcphdr));

    tcp_header.check = checksum((unsigned short*)pseudopacket, packet_size);
    delete[] pseudopacket;  // free the temporary buffer
    ip_header.check = checksum((unsigned short*)&ip_header, sizeof(ip_header));

    // joining two packet headers into one
    int p_size = sizeof(ip_header) + sizeof(struct tcphdr);
    char* packet = new char[p_size];
    memcpy(packet, &ip_header, sizeof(ip_header));
    memcpy(packet + sizeof(ip_header), &tcp_header, sizeof(struct tcphdr));

    struct sockaddr_in dest;
    dest.sin_family = AF_INET;
    dest.sin_port = htons(port);
    dest.sin_addr.s_addr = inet_addr(destination.c_str());

    const int enable = 1;
    if (setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &enable, sizeof(enable)) < 0) {
      perror("Error setsockopt");
      close(sockfd);
      delete[] packet;
      return 1;
    }

    // actual send
    if (sendto(sockfd, packet, p_size, 0, (struct sockaddr*)&dest, sizeof(dest)) < 0) {
      perror("Send failed");
      delete[] packet;
      return 1;
    }

    // we create a while loop to wait for the response

    char resp[66538];                       // resp syze with payload
    struct sockaddr_storage sender;         // Generic container for any address type
    socklen_t sender_len = sizeof(sender);  // beej.us
    std::chrono::steady_clock::time_point start = std::chrono::steady_clock::now();
    while (std::chrono::steady_clock::now() - start
           < std::chrono::milliseconds(GLOBAL_TIMEOUT / 2)) {
      // we will be looking for recvfrom
      ssize_t recv_got = recvfrom(sockfd, resp, 66538, 0, (struct sockaddr*)&sender, &sender_len);
      if (recv_got > 0) {
        // chech if we got syn ack
        struct tcphdr* tcp = (struct tcphdr*)(resp + sizeof(struct iphdr));
        if (ntohs(tcp->source) != port) {
          continue;
        }
        if (tcp->syn && tcp->ack) {
          std::cout << destination << " " << port << " tcp open" << std::endl;
          return 0;
        } else if (tcp->rst) {
          std::cout << destination << " " << port << " tcp closed" << std::endl;
          return 0;
        }
      }
    }

    delete[] packet;

    // after packet being send we need to wait for the response with recvfrom

    return 1;
  } else {
    // here we will be setting ipv6
  }
  // now both adresses will be the same type, we need to craft the ipheader
  // accoring to its ip type
  // because of that we will devide this function from here
};
